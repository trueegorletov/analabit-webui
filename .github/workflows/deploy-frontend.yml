name: Deploy Frontend to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  APP_NAME: 'analabit-webui'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
            
    # Uncomment when tests are ready
    # - name: Run tests
    #   run: npm run test -- --passWithNoTests
      
    - name: Build application
      run: npm run build:production
      
    - name: Create deployment package
      run: |
        tar -czf deployment-package.tar.gz \
          .next \
          public \
          package.json \
          package-lock.json \
          next.config.ts \
          --exclude=node_modules
      
    - name: Upload deployment package
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package
        path: deployment-package.tar.gz
        retention-days: 7

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package
        
    - name: Deploy to production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_HOST }}
        username: analabit
        key: ${{ secrets.PROD_SSH_KEY }}
        script: |
          set -e
          
          # Configuration
          APP_NAME="${{ env.APP_NAME }}"
          APP_DIR="/opt/${APP_NAME}"
          STAGING_DIR="/tmp/${APP_NAME}-staging-$(date +%s)"
          BACKUP_DIR="/opt/${APP_NAME}-backup"
          SERVICE_NAME="${APP_NAME}"
          HEALTH_URL="http://localhost:3000"
          
          echo "ðŸš€ Starting deployment of ${APP_NAME}..."
          
          # Create staging directory
          mkdir -p "$STAGING_DIR"
          cd "$STAGING_DIR"
          
          echo "ðŸ“¦ Setting up Node.js environment..."
          # Ensure we have the right Node.js version
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          nvm use ${{ env.NODE_VERSION }} || nvm install ${{ env.NODE_VERSION }}
          
          echo "ðŸ“¥ Downloading and extracting deployment package..."
          # Note: The artifact will be uploaded separately via SCP
          # For now, we'll use git approach but with proper error handling
          
          # Check if current app directory exists and backup if needed
          if [ -d "$APP_DIR" ]; then
            echo "ðŸ’¾ Creating backup of current deployment..."
            sudo rm -rf "$BACKUP_DIR" || true
            sudo cp -r "$APP_DIR" "$BACKUP_DIR" || true
          fi
          
          # Handle repository setup in staging
          if [ -d "$APP_DIR/.git" ]; then
            echo "ðŸ“‹ Copying existing repository..."
            cp -r "$APP_DIR" "$STAGING_DIR/app"
            cd "$STAGING_DIR/app"
            git fetch origin main
            git reset --hard origin/main
          else
            echo "ðŸ”„ Fresh repository clone..."
            # Remove any existing non-git content from app dir
            sudo rm -rf "$APP_DIR" || true
            mkdir -p "$APP_DIR"
            
            # Clone to staging first
            git clone https://github.com/${{ github.repository }}.git "$STAGING_DIR/app"
            cd "$STAGING_DIR/app"
          fi
          
          echo "ðŸ“¦ Installing dependencies..."
          npm ci --only=production
          
          echo "ðŸ—ï¸ Building application..."
          npm run build:production
          
          echo "âš¡ Performing atomic deployment..."
          # Stop the service before deployment
          sudo systemctl stop "$SERVICE_NAME" || true
          
          # Atomic move to final location
          if [ -d "$APP_DIR" ]; then
            sudo rm -rf "$APP_DIR"
          fi
          sudo mv "$STAGING_DIR/app" "$APP_DIR"
          
          # Set proper ownership
          sudo chown -R analabit:analabit "$APP_DIR"
          
          # Start the service
          echo "ðŸ”„ Starting ${SERVICE_NAME} service..."
          sudo systemctl start "$SERVICE_NAME"
          sudo systemctl enable "$SERVICE_NAME"
          
          # Wait for service to be ready
          echo "â³ Waiting for service to be ready..."
          sleep 15
          
          # Health check with retries
          echo "ðŸ” Performing health check..."
          HEALTH_CHECK_RETRIES=6
          HEALTH_CHECK_DELAY=10
          
          for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
            if curl -f -s "$HEALTH_URL" > /dev/null 2>&1; then
              echo "âœ… Health check passed!"
              break
            elif [ $i -eq $HEALTH_CHECK_RETRIES ]; then
              echo "âŒ Health check failed after $HEALTH_CHECK_RETRIES attempts"
              echo "ðŸ”„ Rolling back to previous version..."
              
              # Rollback procedure
              if [ -d "$BACKUP_DIR" ]; then
                sudo systemctl stop "$SERVICE_NAME" || true
                sudo rm -rf "$APP_DIR"
                sudo mv "$BACKUP_DIR" "$APP_DIR"
                sudo systemctl start "$SERVICE_NAME"
                echo "ðŸ’¾ Rollback completed"
              fi
              
              exit 1
            else
              echo "â³ Health check attempt $i/$HEALTH_CHECK_RETRIES failed, retrying in ${HEALTH_CHECK_DELAY}s..."
              sleep $HEALTH_CHECK_DELAY
            fi
          done
          
          # Cleanup
          echo "ðŸ§¹ Cleaning up..."
          rm -rf "$STAGING_DIR"
          
          # Remove old backups (keep only latest)
          find /opt -name "${APP_NAME}-backup-*" -type d -mtime +7 -exec sudo rm -rf {} + 2>/dev/null || true
          
          echo "ðŸŽ‰ Deployment of ${APP_NAME} completed successfully!"
          echo "ðŸ“Š Service status:"
          sudo systemctl status "$SERVICE_NAME" --no-pager -l
